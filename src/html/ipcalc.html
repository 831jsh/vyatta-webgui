<!--
/*
 *  Copyright 2006, Vyatta, Inc.
 *
 *  GNU General Public License
 * 
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License, version 2, 
 *  as published by the Free Software Foundation.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 *  02110-1301 USA
 *
 *  Module:           ipcalc.html
 *
 *  Original Author:  DHAP Digital, Inc.  Douglas Good & others
 *  Other Author(s):  Marat Nepomnyashy
 *  Date:             2006
 *  Description:      GUI IP Subnet calculator
 *
 */
 -->

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Vyatta | IP Subnet Mask Calculator</title>

<style type="text/css">@import "css/main.css";</style>
<script type="text/javascript">


///////////////////////////////////////
// javascript utility functions 
///////////////////////////////////////

function addEvent(elm, evType, fn, useCapture)
{
	if (elm.addEventListener)
	{
		elm.addEventListener(evType, fn, useCapture);
		return true;
	} 
	else if (elm.attachEvent)
	{
		var r = elm.attachEvent('on' + evType, fn);
		return r;
	}
	else
	{
		elm['on' + evType] = fn;
	}
}

///////////////////////////////////////
// bit manipulation utility functions 
///////////////////////////////////////

function octetsToIPAddr( octet )
{
	return (octet.oct1 << 24) | (octet.oct2 << 16) | (octet.oct3 << 8) | octet.oct4;
}

function ipAddrToOctets( ipAddr )
{
	var o = new Object;
	
	o.oct1 = (ipAddr & 0xFF000000) >>> 24;
	o.oct2 = (ipAddr & 0x00FF0000) >>> 16;
	o.oct3 = (ipAddr & 0x0000FF00) >>> 8;
	o.oct4 = (ipAddr & 0x000000FF);
	
	return o;
}

function netmaskFromBitWidth( netmask_width )
{
	return 0xFFFFFFFF & ( 0xFFFFFFFF << (32 - netmask_width));
}

function bitsInMaskOctet( oct )
{
	if ( (oct & 128) == 0 ) return 0;
	if ( (oct & 64) == 0 )  return 1;
	if ( (oct & 32) == 0 )  return 2;
	if ( (oct & 16) == 0 )  return 3;
	if ( (oct & 8) == 0 )   return 4;
	if ( (oct & 4) == 0 )   return 5;
	if ( (oct & 2) == 0 )   return 6;
	if ( (oct & 1) == 0 )   return 7;
	
	return 8;
}

function calcClass(octet)
{
	var oct1 = octet.oct1;
	
	if (oct1 > 0)
	{
		if ((oct1 & 128) == 0)   return 'A';
		if ((oct1 & 192) == 128) return 'B';
		if ((oct1 & 224) == 192) return 'C';
		if ((oct1 & 240) == 224) return 'D multicast';
		if ((oct1 & 240) == 240) return 'E experimental';
	}
	
	return 'illegal';
}

function getOctetInput( field_prefix )
{
	// Get octets user entered.
	var addr_oct1 = document.getElementById(field_prefix + '_oct1');
	var oct1 = addr_oct1.value;
	if (oct1 > 255) oct1 = 255;

	var addr_oct2 = document.getElementById(field_prefix + '_oct2');
	var oct2 = addr_oct2.value;
	if (oct2 > 255) oct2 = 255;

	var addr_oct3 = document.getElementById(field_prefix + '_oct3');
	var oct3 = addr_oct3.value;
	if (oct3 > 255) oct3 = 255;

	var addr_oct4 = document.getElementById(field_prefix +'_oct4');
	var oct4 = addr_oct4.value;
	if (oct4 > 255) oct4 = 255;
	
	var octet = new Object;
	octet.oct1 = oct1;
	octet.oct2 = oct2;
	octet.oct3 = oct3;
	octet.oct4 = oct4;
	
	return octet;
}

function defaultMaskForClass( net_class )
{
	if ( net_class == "A" ) return 8;
	if ( net_class == "B" ) return 16;
	if ( net_class == "C" ) return 24;
	
	return 24;
}

function resetIPAddr(e, prefix)
{
	var addr_oct1 = document.getElementById( prefix + '_oct1');
	addr_oct1.value = '';

	var addr_oct2 = document.getElementById( prefix + '_oct2');
	addr_oct2.value = '';

	var addr_oct3 = document.getElementById( prefix + '_oct3');
	addr_oct3.value = '';

	var addr_oct4 = document.getElementById( prefix + '_oct4');
	addr_oct4.value = '';
}

function formatOctet( octet )
{
	return octet.oct1 + "." + octet.oct2 + "." + octet.oct3 + "." + octet.oct4;
}



///////////////////////////////////////
// IP subnet calculator
///////////////////////////////////////

function resetNodesReq(e)
{
	var nodes_req = document.getElementById('nodes_req');
	nodes_req.value = '0';
}

function resetSubnetsReq(e)
{
	var subnets_req = document.getElementById('subnets_req');
	subnets_req.value = '0';
}

function resetSubnetClass(e)
{
	var subnet_class_def = document.getElementById('subnet_class_def');
	subnet_class_def.checked = true;

	var subnet_class_a = document.getElementById('subnet_class_a');
	subnet_class_a.checked = false;

	var subnet_class_b = document.getElementById('subnet_class_b');
	subnet_class_b.checked = false;

	var subnet_class_c = document.getElementById('subnet_class_c');
	subnet_class_c.checked = false;
}

function clearAll(e)
{
	resetIPAddr(e, 'addr');
	resetSubnetClass(e);
	resetNodesReq(e);
	resetSubnetsReq(e);
}

function helpPopup(e)
{
	window.alert('Help content forthcoming.');
}


function addrOctKey(e)
{
	// get event
	if( !e ) {
		//if the browser did not pass the event information to the
		//function, we will have to obtain it from the event register
		if( window.event ) {
			//DOM
			e = window.event;
		} else {
			//TOTAL FAILURE, WE HAVE NO WAY OF REFERENCING THE EVENT
			return;
		}
	}
	
	// get entry field
	var field;
	if (e.target)
	{
		field = e.target;
	} 
	else if (e.srcElement)
	{
		field = e.srcElement;
	}
	
	var field_value = field.value;
	var field_id = field.id;
	var field_prefix = field_id.substr(0, field_id.length - 5);

	// correct for NumPad digits
	var charCode = e.keyCode ;
	if (charCode >= 96 && charCode <= 105) {
		charCode = charCode - 48;
	}
	var key = String.fromCharCode( charCode );
	
	// advance to the next field if the period key is hit
	// or the field is full.
	if ( (field_value.substr(field_value.length - 1, 1) == '.') || 
	     ((field_value.length == 3) && /\d/.test(key)) )
	{
		var new_value = field_value;
		if ( field_value.substr(field_value.length - 1, 1) == '.' )
		{
			// erase period from field
			new_value = field_value.substr(0, field_value.length -1);
			field.value = new_value;	
		}
		
		if ( new_value.length > 0 )
		{
			// tab to next field
			var nextfield = null;
			if (field.id == ( field_prefix + '_oct1' ))
			{
				nextfield = document.getElementById( field_prefix + '_oct2' );
			}
			else if (field.id == ( field_prefix + '_oct2' ))
			{
				nextfield = document.getElementById( field_prefix + '_oct3' );
			}
			else if (field.id == ( field_prefix + '_oct3' ))
			{
				nextfield = document.getElementById( field_prefix + '_oct4' );
			}
			if ( nextfield != null )
			{
				field.blur();
				nextfield.focus();
				nextfield.select();
				if (e.returnValue)
				{
					e.returnValue = false;
				}
				if (e.preventDefault)
				{
					e.preventDefault();
				}
			}
		}
	}	
}

function classBits( subnet_net_class )
{
	if (subnet_net_class == 'A') return 1;
	if (subnet_net_class == 'B') return 2;
	if (subnet_net_class == 'C') return 3;
	
	return 0;
}

function calcSupernet( network_mask_width, other_mask_width, net_class, subnet_net_class )
{
	var retval = new Object;
	
	var class_bit_width = classBits( net_class );
	
	var new_network_mask_width = ( 32 - other_mask_width );	
	if ( new_network_mask_width <= class_bit_width )
	{
		retval.new_subnet_net_class = "illegal";
		retval.new_network_mask_width = 0;
		return retval;
	}
	
	var new_subnet_net_class = 'A';
	if ( new_network_mask_width <= 8 )
	{
	 	new_subnet_net_class = 'A';
	}
	if ( new_network_mask_width <= 16 )
	{
	 	new_subnet_net_class = 'B';
	}
	if ( new_network_mask_width <= 8 )
	{
	 	new_subnet_net_class = 'C';
	}

	retval.new_network_mask_width = new_network_mask_width;
	retval.new_subnet_net_class = new_subnet_net_class;
	
	return retval;	
}

function calcSubnets( ip_octet, net_class, subnet_net_class, subnet_count, node_count )
{
	var ip_addr = octetsToIPAddr( ip_octet );
	
	var class_mask_width   = defaultMaskForClass( subnet_net_class );
	var subnet_mask_width  = 0;
	var host_mask_width    = 0;
	var network_mask_width = 0;
	var subsuper = "subnetted";
	
	// Determine size of class, subnet, and host mask widths
	if (subnet_count == 0)
	{
		// nodes needed
		host_mask_width = Math.round(Math.log(node_count) / Math.LN2);
		
		if ( (host_mask_width + class_mask_width) > (32 - classBits( subnet_net_class )) )
		{
			var supernet = calcSupernet( class_mask_width, host_mask_width, net_class, subnet_net_class );
			network_mask_width = supernet.new_network_mask_width;
			subnet_mask_width = 0;
			subnet_net_class = supernet.new_subnet_net_class;
			subsuper = "supernetted";
		}
		else
		{
			subnet_mask_width = 32 - class_mask_width - host_mask_width;
			network_mask_width = class_mask_width + subnet_mask_width;
		}
	}
	else
	{
		// subnets needed
		subnet_mask_width = Math.round(Math.log(subnet_count) / Math.LN2);
		if ( (subnet_mask_width + class_mask_width) > (32 - classBits( subnet_net_class )) )
		{
			// need host mask width of at least two, for four hosts on each subnet
			var supernet = calcSupernet( class_mask_width, class_mask_width + 2, subnet_net_class );
			network_mask_width = supernet.new_network_mask_width;
			host_mask_width = 2;
			subnet_net_class = supernet.new_subnet_net_class;
			subsuper = "supernetted";
		}
		else
		{
			host_mask_width = 32 - class_mask_width - subnet_mask_width;
			network_mask_width = class_mask_width + subnet_mask_width;
		}
	}
	
	// Calculate network mask and address to contain subnets
	var network_mask = netmaskFromBitWidth( network_mask_width );
	var network_addr = ip_addr & network_mask;
	
	// Store into result object
	var result = ipAddrToOctets( network_addr );
	
	if ( subnet_net_class != "illegal" )
	{
		result.mask               = network_mask;
		result.network_mask_width = network_mask_width;
		
		result.class_mask_width   = class_mask_width;
		result.subnet_mask_width  = subnet_mask_width;
		result.host_mask_width    = host_mask_width;
		
		result.subnet_net_class   = subnet_net_class;
		result.net_class          = net_class;
		result.subnet_count       = Math.round(Math.pow(2, subnet_mask_width));
		result.host_count         = Math.round(Math.pow(2, host_mask_width));
		result.subsuper           = subsuper;
	}
	else
	{
		result.oct1               = 0;
		result.oct2               = 0;
		result.oct3               = 0;
		result.oct4               = 0;
		
		result.mask               = 0;
		result.network_mask_width = 0;
		
		result.class_mask_width   = 0;
		result.subnet_mask_width  = 0;
		result.host_mask_width    = 0;
		
		result.subnet_net_class   = subnet_net_class;
		result.net_class          = net_class;
		result.subnet_count       = 0;
		result.host_count         = 0;
		result.subsuper           = "illegal";
	}
	
	return result;
}

function calculate(e)
{
	// input: network IP addr
	var ip_addr = getOctetInput('addr');
	
	// input: subnet as class
	var net_class = calcClass(ip_addr);
	if ((net_class != 'A') && (net_class != 'B') && (net_class != 'C'))
	{
		alert("Please enter a valid class A, B, or C network address.");
		return;
	}
	var subnet_net_class = net_class;
	var subnet_class_a = document.getElementById('subnet_class_a');
	if ( subnet_class_a.checked )
	{
		subnet_net_class = 'A';
	}
	
	var subnet_class_b = document.getElementById('subnet_class_b');
	if ( subnet_class_b.checked )
	{
		subnet_net_class = 'B';
	}
	
	var subnet_class_c = document.getElementById('subnet_class_c');
	if ( subnet_class_c.checked )
	{
		subnet_net_class = 'C';
	}
	
	// input: network nodes or addresses desired in subnets
	var subnets_req = document.getElementById('subnets_req');
	var subnet_count = subnets_req.value;
	
	var nodes_req = document.getElementById('nodes_req');
	var node_count = nodes_req.value;
	
	if ( (subnet_count == 0) && (node_count == 0) )
	{
		alert("Please choose number of subnets or hosts for your network.");
		return;
	}
	
	// figure out network addr, network mask necessary
	var result = calcSubnets( ip_addr, net_class, subnet_net_class, subnet_count, node_count );
	
	// display results
	var network_out = document.getElementById('network_out');
	network_out.firstChild.nodeValue = formatOctet( result ) + "/" + result.network_mask_width;

	var class_out = document.getElementById('network_class_out');
	if ( result.subsuper == "illegal" )
	{
		class_out.firstChild.nodeValue = result.subsuper;
	}
	else if ( result.subsuper == "supernetted" )
	{
		class_out.firstChild.nodeValue = result.net_class + ", " + result.subsuper;
	}
	else
	{
		class_out.firstChild.nodeValue = result.net_class + ", " + result.subsuper + " as " + result.subnet_net_class;
	}
	
	var subnet_mask_out = document.getElementById('subnet_mask_out');
	var subnet_mask = ipAddrToOctets( result.mask );
	subnet_mask_out.firstChild.nodeValue = formatOctet( subnet_mask );
	
	var subnets_out = document.getElementById('subnets_out');
	subnets_out.firstChild.nodeValue = result.subnet_count;
	
	var nodes_out = document.getElementById('nodes_out');
	nodes_out.firstChild.nodeValue = result.host_count;
	
	// store result for the "list networks" feature
	window.subnet_result = result;
}

function closeListNetworks() {
	document.getElementById("list_networks_display").style.display = "none";
}

function listNetworks(e)
{
	if ( window.subnet_result == null )
	{
		alert("Please calculate a subnet mask first.");
		return;
	}
	var result = window.subnet_result;
	
	if ( result.subnet_net_class == "illegal" )
	{
		alert("Please calculate a legal subnet or supernet mask first.");
		return;	
	}
	
	subnet_doc = "";
	subnet_doc += '<div style="text-align:right"><a href="javascript:;" onclick="closeListNetworks();return false;"><img src="images/close_button.gif" width="47" height="13" alt="close"><\a><\/div>';
	subnet_doc += '<h1>List of networks<\/h1>';
	var subnet_mask = ipAddrToOctets( result.mask );
	subnet_doc += '<p><strong>Network:<\/strong> ' + formatOctet( result ) + "/" + result.network_mask_width +
	'<\/p>';
	subnet_doc += '<p><strong>Net mask:<\/strong> ' + formatOctet( subnet_mask ) + '<\/p>';
	subnet_doc += '<table border="0" cellpadding="5" cellspacing="0">';
	subnet_doc += '<tr><th>Network<\/th><th>Min Host<\/th><th>Max Host<\/th><th>Broadcast Address<\/th><\/tr>';
	
	// get network and subnet information
	var class_mask_width = result.class_mask_width;
	var subnet_mask_width = result.subnet_mask_width;
	var host_mask_width = result.host_mask_width;
	var subnet_count = result.subnet_count;
	var host_count = result.host_count;

	if (subnet_count > 16384)
	{
		alert("Sorry, but there are too many subnets to list.");
		return;	
	}
	
	var network_class_mask = netmaskFromBitWidth( class_mask_width );	
	var network_class = octetsToIPAddr(result) & network_class_mask;
	
	// iterate through subnet extensions:
	var subnet = 0;
	for (subnet = 0; subnet < subnet_count; subnet++)
	{
		// generate network for this subnet (network class + subnet extension)
		var subnet_extension = (subnet << host_mask_width);
		var network_addr = (network_class | subnet_extension);
		var network_octet = ipAddrToOctets( network_addr );
		
		// calculate min, max, broadcast address for each network
		var min_addr = (network_addr | 1);
		var max_addr = (network_addr | ( host_count - 2 ));
		var broadcast_addr = network_addr | ( host_count - 1 );
		
		var min_octet = ipAddrToOctets( min_addr );
		var max_octet = ipAddrToOctets( max_addr );
		var broadcast_octet = ipAddrToOctets( broadcast_addr );
		
		// add a line to the table	
		subnet_doc += '<tr><td>' + formatOctet(network_octet) +
				 '<\/td><td>' + formatOctet(min_octet) +
				 '<\/td><td>' + formatOctet(max_octet) +
				 '<\/td><td>' + formatOctet(broadcast_octet) +
				 '<\/td><\/tr>';
	}
	
	// close table and page
	subnet_doc += "<\/table>";
	var displayArea = document.getElementById("list_networks_display");
	displayArea.style.display = "block";
	displayArea.innerHTML = subnet_doc;
}

function setupIPCalc()
{
	var addr_oct1 = document.getElementById('addr_oct1');
	addEvent( addr_oct1, 'keyup', addrOctKey, false );

	var addr_oct2 = document.getElementById('addr_oct2');
	addEvent( addr_oct2, 'keyup', addrOctKey, false );
	
	var addr_oct3 = document.getElementById('addr_oct3');
	addEvent( addr_oct3, 'keyup', addrOctKey, false );
	
	var addr_oct4 = document.getElementById('addr_oct4');
	addEvent( addr_oct4, 'keyup', addrOctKey, false );
	
	var subnets_req = document.getElementById('subnets_req');
	addEvent( subnets_req, 'change', resetNodesReq, false );
	
	var nodes_req = document.getElementById('nodes_req');
	addEvent( nodes_req, 'change', resetSubnetsReq, false );

	var calculate_button = document.getElementById('calculate');
	addEvent( calculate_button, 'click', calculate, false );
	
	var clear_all = document.getElementById('clear_all');
	addEvent( clear_all, 'click', clearAll, false );

	//var help_button = document.getElementById('help');
	//addEvent( help_button, 'click', helpPopup, false );
	
	var list_networks_button = document.getElementById('list_networks');
	addEvent( list_networks_button, 'click', listNetworks, false );
}

///////////////////////////////////////
// subnet mask converter 
///////////////////////////////////////

function validateOctet( oct )
{
	if (oct == 0)   return true;
	if (oct == 128) return true;
	if (oct == 192) return true;
	if (oct == 224) return true;
	if (oct == 240) return true;
	if (oct == 248) return true;
	if (oct == 252) return true;
	if (oct == 254) return true;
	if (oct == 255) return true;
	
	return false;
}

// Performs partial validation.  Allows user to enter netmasks
// that are not legal, such as 192.255.255.0.
function validateMaskOctets(octet)
{
	if (!validateOctet(octet.oct1)) return false;
	if (!validateOctet(octet.oct2)) return false;
	if (!validateOctet(octet.oct3)) return false;
	if (!validateOctet(octet.oct4)) return false;
	
	return true;
}

function calcNetmask(e)
{
	// input: netmask IP addr
	var netmask_octet = getOctetInput('netmask');
	var netmask = octetsToIPAddr( netmask_octet );
	
	// input: netmask bit width
	var netmask_field = document.getElementById('netmask_width');
	var netmask_width = netmask_field.value;
	
	// validate inputs
	if ( (netmask == 0) && (netmask_width.length == 0) )
	{
		alert("Please enter a netmask, or a netmask bit width.");
		return;
	}
	if ( (netmask != 0) && (netmask_width.length > 0) )
	{
		alert("Please enter either a netmask, or a netmask bit width, but not both at once.");
		return;
	}
	if ( netmask_width.length > 0 && ((netmask_width < 0) || (netmask_width > 32)) )
	{
		alert("Please enter a netmask bit width between 0 and 32.");
		return;
	}
	if ( netmask != 0 )
	{
		if ( !validateMaskOctets(netmask_octet) )
		{
			alert("Valid netmask values are:\n0, 128, 192, 224, 240, 248, 252, 254, and 255.");
			return;
		}
	}
	
	// depending on which was selected, calcluate the other
	if ( netmask == 0 )
	{
		// generate netmask from width
		netmask = netmaskFromBitWidth( netmask_width );
		netmask_octet = ipAddrToOctets( netmask );	
	}
	else
	{
		// generate width from netmask
		netmask_width = bitsInMaskOctet( netmask_octet.oct1 ) +
				bitsInMaskOctet( netmask_octet.oct2 ) +
				bitsInMaskOctet( netmask_octet.oct3 ) +
				bitsInMaskOctet( netmask_octet.oct4 );
	}
	
	// display result
	var netmask_out = document.getElementById('netmask_out');
	netmask_out.firstChild.nodeValue = formatOctet( netmask_octet );
	
	var netmask_width_out = document.getElementById('netmask_width_out');
	netmask_width_out.firstChild.nodeValue = netmask_width;
}

function clearNetmask(e)
{
	resetIPAddr(e, 'netmask');
	var netmask_field = document.getElementById('netmask_width');
	netmask_field.value = '';
}

function helpNetmask(e)
{
	window.alert("Help content forthcoming.");
}

function setupNetmaskConverter()
{
	var netmask_oct1 = document.getElementById('netmask_oct1');
	addEvent( netmask_oct1, 'keyup', addrOctKey, false );

	var netmask_oct2 = document.getElementById('netmask_oct2');
	addEvent( netmask_oct2, 'keyup', addrOctKey, false );
	
	var netmask_oct3 = document.getElementById('netmask_oct3');
	addEvent( netmask_oct3, 'keyup', addrOctKey, false );
	
	var netmask_oct4 = document.getElementById('netmask_oct4');
	addEvent( netmask_oct4, 'keyup', addrOctKey, false );
	
	var calc_netmask = document.getElementById('calc_netmask');
	addEvent( calc_netmask, 'click', calcNetmask, false );
	
	var clear_netmask = document.getElementById('clear_netmask');
	addEvent( clear_netmask, 'click', clearNetmask, false );

	//var help_netmask = document.getElementById('help_netmask');
	//addEvent( help_netmask, 'click', helpNetmask, false );	
}

///////////////////////////////////////
// main
///////////////////////////////////////

function setup()
{
	setupIPCalc();
	setupNetmaskConverter();
	pageForms = document.getElementsByTagName('form');
	for(i=0; i<pageForms.length; i++) {
		pageForms[i].autocomplete='off';
	}
	var currentWidth;
	var currentHeight;
	var desiredWidth = 600;
	var desiredHeight = 700;
	this.resizeTo(desiredWidth,desiredHeight);

	var addr_oct1 =  document.getElementById('addr_oct1');
	addr_oct1.focus();
}


addEvent(window, 'load', setup, false);



</script>

</head>

<body id="popupBody">

<div id="popupHeader"><div id="popupHeaderTitle">Subnet Calculator</div><img src="images/popup_header.gif" alt="Route Logics" width="180" height="40"></div>

<div id="popupContent">
	
	<div class="sub_hdr_div">
		<div class="float_right"><img src="images/sub_hdr_corner_right.gif" alt="" width="16" height="27"></div>
		<div class="float_left"><img src="images/sub_hdr_corner_left.gif" alt="" width="18" height="27"></div>
		<h2>IP Subnet Mask Calculator</h2>
	</div>
	
	<h3>Enter:</h3>
	
	<form action="ipcalc.html" method="get">
		<table>	
			<tr>
				<td align="right" valign="top"><label for="addr_oct1">TCP/IP Network address:</label></td>
				<td>
				<input name="addr_oct1" id="addr_oct1" type="text" size="3" maxlength="3">&nbsp;.&nbsp;
				<input name="addr_oct2" id="addr_oct2" type="text" size="3" maxlength="3">&nbsp;.&nbsp;
				<input name="addr_oct3" id="addr_oct3" type="text" size="3" maxlength="3">&nbsp;.&nbsp;
				<input name="addr_oct4" id="addr_oct4" type="text" size="3" maxlength="3">
				</td>
			</tr>
			<tr>
				<td align="right" valign="top"><label for="subnet_class">Subnet as class:</label></td>
				<td>
				<input name="subnet_class" id="subnet_class_def" type="radio" value="default" checked>Default<br>
				<input name="subnet_class" id="subnet_class_a" type="radio" value="A">Class A<br>
				<input name="subnet_class" id="subnet_class_b" type="radio" value="B">Class B<br>
				<input name="subnet_class" id="subnet_class_c" type="radio" value="C">Class C
				</td>
			</tr>
			<tr>
				<td colspan="2"><h3>Choose one of the following:</h3></td>
			</tr>
			<tr>
				<td align="right" valign="top"><label for="subnets_req">Subnets required:</label></td>
				<td>
					<select name="subnets_req" id="subnets_req">
					<option value="0"></option>
					<option value="1">1</option>
					<option value="2">2</option>
					<option value="4">4</option>
					<option value="8">8</option>
					<option value="16">16</option>
					<option value="32">32</option>
					<option value="64">64</option>	
					<option value="128">128</option>
					<option value="256">256</option>
					<option value="512">512</option>
					<option value="1024">1024</option>
					<option value="2048">2048</option>
					<option value="4096">4096</option>	
					<option value="8192">8192</option>
					<option value="16384">16384</option>
					<option value="32768">32768</option>
					<option value="65536">65536</option>
					<option value="131072">131072</option>
					<option value="262144">262144</option>	
					<option value="524288">524288</option>
					<option value="1048576">1048576</option>
					<option value="2097152">2097152</option>
					<option value="4194304">4194304</option>
					<option value="8388608">8388608</option>
					</select>
				</td>	
			</tr>
		
		<tr>
			<td align="right" valign="top"><label for="nodes_req">Nodes/Hosts required:</label></td>
			<td>
				<select name="nodes_req" id="nodes_req">
				<option value="0"></option>
				<option value="1">1</option>
				<option value="2">2</option>
				<option value="4">4</option>
				<option value="8">8</option>
				<option value="16">16</option>
				<option value="32">32</option>
				<option value="64">64</option>
				<option value="128">128</option>
				<option value="256">256</option>
				<option value="512">512</option>
				<option value="1024">1024</option>
				<option value="2048">2048</option>
				<option value="4096">4096</option>	
				<option value="8192">8192</option>
				<option value="16384">16384</option>
				<option value="32768">32768</option>
				<option value="65536">65536</option>
				<option value="131072">131072</option>
				<option value="262144">262144</option>	
				<option value="524288">524288</option>
				<option value="1048576">1048576</option>
				<option value="2097152">2097152</option>
				<option value="4194304">4194304</option>
				<option value="8388608">8388608</option>
				<option value="16777216">16777216</option>
				<option value="33554432">33554432</option>
				<option value="67108864">67108864</option>
				<option value="134217728">134217728</option>
				<option value="268435456">268435456</option>
				<option value="536870912">536870912</option>
				<option value="1073741824">1073741824</option>
				<option value="2147483648">2147483648</option>
				</select>
				<span class="note">(including network and broadcast addresses)</span>
			</td>	
		</tr>
		<tr>
			<td>&nbsp;</td><td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td align="left">
				<img src="images/bt_calculate.gif" border="0" width="70" height="17" id="calculate" alt="Calculate">
				<img src="images/bt_clear_all.gif" border="0" width="65" height="17" id="clear_all" alt="Clear All">
				<!--<input type="button" name="help" id="help" value="Help">-->
			</td>
		</tr>
		<tr>
			<td colspan="2"><h3>Results:</h3></td>
		</tr>
		<tr>
			<td align="right">Network:</td>
			<td><span id="network_out">&nbsp;</span></td>
		</tr>
		<tr>
			<td align="right">Network Class:</td>
			<td><span id="network_class_out">&nbsp;</span></td>
		</tr>
		<tr>
			<td align="right">Subnet Mask:</td>
			<td><span id="subnet_mask_out">&nbsp;</span></td>
		</tr>
		<tr>
			<td align="right">Subnets:</td>
			<td><span id="subnets_out">&nbsp;</span></td>
		</tr>
		<tr>
			<td align="right">Nodes/hosts:</td>
			<td><span id="nodes_out">&nbsp;</span></td>
		</tr>
		<tr>
			<td>&nbsp;</td><td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td><img src="images/bt_list_networks.gif" border="0" width="88" height="17" id="list_networks" alt="List Networks"></td>
		</tr>
	</table>
	<div id="list_networks_display" style="display:none"></div>
	</form>
		
	<div class="sub_hdr_div">
		<div class="float_right"><img src="images/sub_hdr_corner_right.gif" alt="" width="16" height="27"></div>
		<div class="float_left"><img src="images/sub_hdr_corner_left.gif" alt="" width="18" height="27"></div>
		<h2>Subnet Mask Converter</h2>
	</div>
	
	<form action="ipcalc.html" method="get">
		<table>
			<tr>
				<td><h3>Enter one of the following:</h3></td><td>&nbsp;</td>
			</tr>
			<tr>
				<td align="right" valign="top"><label for="netmask_oct1">Dotted decimal Subnet Mask:</label></td>
				<td>
				<input name="netmask_oct1" id="netmask_oct1" type="text" size="3" maxlength="3">&nbsp;.&nbsp;
				<input name="netmask_oct2" id="netmask_oct2" type="text" size="3" maxlength="3">&nbsp;.&nbsp;
				<input name="netmask_oct3" id="netmask_oct3" type="text" size="3" maxlength="3">&nbsp;.&nbsp;
				<input name="netmask_oct4" id="netmask_oct4" type="text" size="3" maxlength="3">
				</td>
			</tr>
			<tr>
				<td align="right" valign="top"><label for="netmask_width">Subnet Mask bit width:</label></td>
				<td><input name="netmask_width" id="netmask_width" type="text" size="2" maxlength="2"></td>
			</tr>
			<tr>
				<td>&nbsp;</td><td>&nbsp;</td>
			</tr>
			<tr>
				<td>&nbsp;</td>
				<td>
					<img src="images/bt_calculate.gif" border="0" width="70" height="17" id="calc_netmask" alt="Calculate">
					<img src="images/bt_clear_all.gif" border="0" width="65" height="17" id="clear_netmask" alt="Clear All">
					<!--<input type="button" id="help_netmask" value="Help">-->
				</td>
			</tr>
			<tr>
			<td><h3>Results:</h3></td><td>&nbsp;</td>
			</tr>
			<tr>
				<td align="right" valign="top">Dotted decimal Subnet Mask:</td>
				<td><span id="netmask_out">&nbsp;</span></td>
			</tr>
			<tr>
				<td align="right" valign="top">Subnet Mask bit width:</td>
				<td><span id="netmask_width_out">&nbsp;</span></td>
			</tr>	
		</table>
	</form>

</div> <!-- end 'popupContent' div -->

</body>
</html>